package cmsc433.p2;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;


/**
 * Validates a simulation
 * From Kunal Much Love
 * From Yoonshik Go Caps
 * From John French
 * From Mihai
 */
public class Validate3 {

	private enum OrderStatus {
		Placed,
		Cooking,
		Complete
	};

	private enum CustomerStatus {
		Created,
		Entered,
		PlacedOrder,
		ReceivedOrder,
		Left
	};

	private static class InvalidSimulationException extends Exception {
		private static final long serialVersionUID = 1L;

		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate3.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {

			/* In P2 you will write validation code for things such as:
				Should not have more eaters than specified
				Should not have more cooks than specified
				The Ratsie's capacity should not be exceeded
				The capacity of each machine should not be exceeded
				Eater should not receive order until cook completes it
				Eater should not leave Ratsie's until order is received
				Eater should not place more than one order
				Cook should not work on order before it is placed
			 */

			// Create a list of events that we will modify, remove the starting and ending events
			ArrayList<SimulationEvent> realEvents = new ArrayList<SimulationEvent>();
			realEvents.addAll(events);	

			int expectedNumCooks = 0;
			int expectedNumCustomer = 0;

			int machineCapacity = 0;
			int restaurantCapacity = 0;
			int restaurantUsage = 0;

			HashSet<String> cooks = new HashSet<String>();
			HashMap<Integer, OrderStatus> orderStatus = new HashMap<Integer, OrderStatus>();
			HashMap<String, CustomerStatus> customerStatus = new HashMap<String, CustomerStatus>();
			HashMap<Food, Integer> machineStatus = new HashMap<Food, Integer>();

			Integer index = 0;
			String currName;
			Integer currOrderNum;
			Integer machineUsage;
			for (SimulationEvent currEvent: realEvents) {
				switch(currEvent.event) {
				case CustomerStarting:
					currName = currEvent.customer.getName();
					check(customerStatus.size() < expectedNumCustomer, "Too many customers created");

					check(customerStatus.put(currName, CustomerStatus.Created) == null,
							"Duplicate Customer: " + currName);

					break;
				case CustomerEnteredRatsies:
					currName = currEvent.customer.getName();

					check(restaurantUsage < restaurantCapacity, "Too many customers entered");

					check(
							customerStatus.put(currName, CustomerStatus.Entered) == CustomerStatus.Created,
							"Customer entered Ratsies before being created"
							);
					break;
				case CustomerPlacedOrder:
					currName = currEvent.customer.getName();
					currOrderNum = currEvent.orderNumber;
					check(
							customerStatus.put(currName, CustomerStatus.PlacedOrder) == CustomerStatus.Entered,
							"Customer Placed Order before entering"
							);

					check(
							orderStatus.put(currOrderNum, OrderStatus.Placed) == null,
							"Duplicate Order"
							);

					break;
				case CustomerReceivedOrder:
					currName = currEvent.customer.getName();
					currOrderNum = currEvent.orderNumber;

					check(
							customerStatus.put(currName, CustomerStatus.ReceivedOrder) == CustomerStatus.PlacedOrder,
							"Customer received order before placing it"
							);

					check(
							orderStatus.get(currOrderNum) == OrderStatus.Complete,
							"Customer got order before completion" + currOrderNum
							);

					break;
				case CustomerLeavingRatsies:
					currName = currEvent.customer.getName();

					check(
							customerStatus.put(currName, CustomerStatus.Left) == CustomerStatus.ReceivedOrder,
							"Customer left before getting order"
							);

					restaurantUsage -= 1;
					break;
				case CookStarting:
					currName = currEvent.cook.getName();
					check(!cooks.contains(currName),
							"Duplicate Cook: " + currName);

					check(cooks.size() < expectedNumCooks, "Too many cooks created");

					cooks.add(currName);
					break;
				case CookReceivedOrder:
					currName = currEvent.cook.getName();
					currOrderNum = currEvent.orderNumber;

					check(cooks.contains(currName), "Nonexistent cook working on order");
					check(
							orderStatus.put(currOrderNum, OrderStatus.Cooking) == OrderStatus.Placed,
							"Orders started cooking before customer placed it"	
							);
					break;
				case CookStartedFood: case CookFinishedFood:
					currName = currEvent.cook.getName();
					currOrderNum = currEvent.orderNumber;

					check(cooks.contains(currName), "Nonexistent cook working on order");
					check(
							orderStatus.get(currOrderNum) == OrderStatus.Cooking,
							"Cook started/finished food before starting order"	
							);
					break;
				case CookCompletedOrder:
					currName = currEvent.cook.getName();
					currOrderNum = currEvent.orderNumber;

					check(cooks.contains(currName), "Nonexistent cook working on order");
					check(
							orderStatus.put(currOrderNum, OrderStatus.Complete) == OrderStatus.Cooking,
							"Cook completed order before starting cooking"	
							);
					break;
				case CookEnding:
					currName = currEvent.cook.getName();
					check(cooks.contains(currName), "Nonexistent cook Ended");
					break;
				case MachineStarting:
					check(
							machineStatus.put(currEvent.machine.machineFoodType, 0) == null,
							"Duplicate machine type: " + currEvent.machine.machineFoodType.name
							);
					break;
				case MachineStartingFood:
					machineUsage = machineStatus.get(currEvent.machine.machineFoodType);

					check(machineUsage != null, "Nonexistent machine");

					check(
							machineUsage < machineCapacity,
							"Machine Exceeded Capacity: " + currEvent.machine.machineFoodType.name
							);

					machineStatus.put(currEvent.machine.machineFoodType, machineUsage + 1);
					break;
				case MachineDoneFood:
					machineUsage = machineStatus.get(currEvent.machine.machineFoodType);

					check(machineUsage != null, "Nonexistent machine");

					check(
							machineUsage <= machineCapacity && machineUsage != 0,
							"Invalid machine usage: " + currEvent.machine.machineFoodType.name
							);

					machineStatus.put(currEvent.machine.machineFoodType, machineUsage - 1);
					break;
				case MachineEnding:
					machineUsage = machineStatus.get(currEvent.machine.machineFoodType);

					check(machineUsage != null, "Nonexistent machine");
					check(machineUsage == 0, "Invalid Machine Usage. Shutting down, food should be done");
					break;
				case SimulationEnded:
					check(index == realEvents.size() - 1, 
							"Simulation didn't end with termination event");
					break;
				case SimulationStarting:
					check(index == 0, "Simulation didn't start with initiation event");


					int [] params = currEvent.simParams;

					expectedNumCustomer = params[0];
					expectedNumCooks = params[1];

					restaurantCapacity = params[2];
					machineCapacity = params[3];

					break;
				default:
					check(false, "Invalid SimulationEvent type");
					break;
				}

				index += 1;
			}

			//			HashMap<SimulationEvent.EventType, Integer> numEvents = new HashMap<SimulationEvent.EventType, Integer>();
			//			for(SimulationEvent event: events){
			//				numEvents.put(event.event, numEvents.getOrDefault(event.event,0)+1);
			//				//CustomerStarting
			//				//CustomerLeavingRatsies
			//				if(event.equals( SimulationEvent.EventType.CustomerStarting)){
			//					if (numEvents.getOrDefault(event.event,0) < numEvents.getOrDefault(SimulationEvent.EventType.CustomerLeavingRatsies, 0)){
			//						return false;
			//					}
			//					if (numEvents.getOrDefault(event.event,0) < numEvents.getOrDefault(SimulationEvent.EventType.CustomerReceivedOrder, 0)){
			//						return false;
			//					}
			//					if (numEvents.getOrDefault(event.event,0) < numEvents.getOrDefault(SimulationEvent.EventType.CustomerPlacedOrder, 0)){
			//						return false;
			//					}
			//					if (numEvents.getOrDefault(event.event,0) < numEvents.getOrDefault(SimulationEvent.EventType.CustomerStarting, 0)){
			//						return false;
			//					}
			//				}
			//			}

			
				check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
						"Simulation didn't start with initiation event");
				check(events.get(events.size()-1).event == 
						SimulationEvent.EventType.SimulationEnded,
						"Simulation didn't end with termination event");

				/* In P2 you will write validation code for things such as:
					Should not have more eaters than specified
					Should not have more cooks than specified
					The Ratsie's capacity should not be exceeded
					The capacity of each machine should not be exceeded
					Eater should not receive order until cook completes it
					Eater should not leave Ratsie's until order is received
					Eater should not place more than one order
					Cook should not work on order before it is placed
				 */
						
				int numCustomers = events.get(0).simParams[0];
				int numCooks = events.get(0).simParams[1];
				int numTables = events.get(0).simParams[2];
				machineCapacity = events.get(0).simParams[3];
				
				int cookEnter = 0, cookExit = 0; 
				int cookPlaceOrder = 0, cookCompleteOrder = 0; 
				int customerStart = 0, customerEnter = 0; 
				int customerPlace = 0, customerReceive = 0, customerLeave = 0; 
				
				for(int i = 0; i < events.size(); i++){
					if(events.get(i).event == SimulationEvent.EventType.CookStarting){
						cookEnter++;
					}else if(events.get(i).event == SimulationEvent.EventType.CookEnding){
						cookExit++;
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerStarting){
						customerStart++;
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerEnteredRatsies){
						customerEnter++;
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerPlacedOrder){
						customerPlace++;
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerReceivedOrder){
						customerReceive++;
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerLeavingRatsies){
						customerLeave++;
					}
					else if(events.get(i).event == SimulationEvent.EventType.CookReceivedOrder){
						cookPlaceOrder++;
					}else if(events.get(i).event == SimulationEvent.EventType.CookCompletedOrder){
						cookCompleteOrder++;
					}
				}
				
				
				check(numCooks== cookEnter, "Not all the cooks entered!"); 
				check(numCooks == cookExit, "Not all the cooks exited!");
				check(numCustomers == customerStart, "Not all customers started");
				check(numCustomers == customerEnter, "Not all customers enter");
				check(numCustomers == customerPlace, "Not all customers place order");
				check(numCustomers == customerReceive, "Not all customers received order");
				check(numCustomers == customerLeave, "Not all customers left!");
				check(cookPlaceOrder == numCustomers, "Not all orders received by cook!");
				check(cookCompleteOrder == numCustomers, "Not all orders were completed!");
				
				//Make sure the machines are started before everyone else
				check(events.get(1).event == SimulationEvent.EventType.MachineStarting, 
						"machine not started 1"); 
				check(events.get(2).event == SimulationEvent.EventType.MachineStarting, 
						"machine not started 2");
				check(events.get(3).event == SimulationEvent.EventType.MachineStarting, 
						"machine not started 3");
				check(events.get(4).event == SimulationEvent.EventType.MachineStarting, 
						"machine not started 4");
				
				//Make sure the machine ending is the last thing that happens. 
				check(events.get(events.size() - 2).event == SimulationEvent.EventType.MachineEnding, 
						"machine not finished 1"); 
				check(events.get(events.size() - 3).event == SimulationEvent.EventType.MachineEnding, 
						"machine not finished 2");
				check(events.get(events.size() - 4).event == SimulationEvent.EventType.MachineEnding, 
						"machine not finished 3");
				check(events.get(events.size() - 5).event == SimulationEvent.EventType.MachineEnding, 
						"machine not finished 4");
				
				//Make sure the cooks are the last thing to happen before the machines shutdown
				for(int i = 6; i < 6 + numCooks; i++){
					check(events.get(events.size() - i).event == 
							SimulationEvent.EventType.CookEnding, 
							"Cook not leaving after everyone else!");
				}
				
				//SimulationEvent e = events.get(0);
				//System.out.println(Arrays.toString(e.simParams));

				HashMap<String, ArrayList<SimulationEvent>> eventsMap = new 
						HashMap<String, ArrayList<SimulationEvent>>();
				
				//Now this is where it gets more complicated!!
				
				//SECTION 1: Make sure all the customers follow the right oder. 
				for(int i = 0; i < events.size(); i++){
					
					//For the customers!!
					ArrayList<SimulationEvent> e; 
					
					//Make sure the customer first message is them actually starting!
					if(events.get(i).event == SimulationEvent.EventType.CustomerStarting){
						String cust = events.get(i).customer.toString();
						check(!eventsMap.containsKey(cust),
								cust + " has already started!"); 
						e = new ArrayList<SimulationEvent>(); 
						e.add(events.get(i));
						eventsMap.put(cust,e);
						
					//If they enter, the next step is to make sure they first started!
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerEnteredRatsies){
						String cust = events.get(i).customer.toString();
						e = eventsMap.get(cust);
						check(e != null, cust + " has no record!");
						check(e.size() == 1, cust + " event array has weird size");
						check(e.get(0).event == SimulationEvent.EventType.CustomerStarting, 
								cust + " did not start first before entering!"); 
						e.add(events.get(i));
					
					//Now we have to make sure the customer actually placed an order after starting
					//and entering
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerPlacedOrder){
						String cust = events.get(i).customer.toString();
						e = eventsMap.get(cust);
						
						check(e != null, cust + " has no record!");
						check(e.size() == 2, cust + " event array has weird size");
						check(e.get(0).event == SimulationEvent.EventType.CustomerStarting, 
								cust + " did not start first before placing!"); 
						check(e.get(1).event == SimulationEvent.EventType.CustomerEnteredRatsies, 
								cust + " did not enter Ratsie before placing!"); 
						
						e.add(events.get(i));
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerReceivedOrder){
						String cust = events.get(i).customer.toString();
						e = eventsMap.get(cust);
						
						check(e != null, cust + " has no record!");
						check(e.size() == 3, cust + " event array has weird size");
						check(e.get(0).event == SimulationEvent.EventType.CustomerStarting, 
								cust + " did not start first! before receiving"); 
						check(e.get(1).event == SimulationEvent.EventType.CustomerEnteredRatsies, 
								cust + " did not enter Ratsie! before receiving");
						check(e.get(2).event == SimulationEvent.EventType.CustomerPlacedOrder,
								cust + " did not place an order before receiving");
						
						//Make sure the food orders are identical! 
						for(int j = 0; j < e.get(2).orderFood.size(); j++){
							check(e.get(2).orderFood.get(j) == events.get(i).orderFood.get(j),
									cust + " food order has been changed between start and finish!"); 
						}
						e.add(events.get(i));
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerLeavingRatsies){
						String cust = events.get(i).customer.toString();
						e = eventsMap.get(cust);
						
						check(e != null, cust + " has no record!");
						check(e.size() == 4, cust + " event array has weird size");
						check(e.get(0).event == SimulationEvent.EventType.CustomerStarting, 
								cust + " did not start first! before leaving"); 
						check(e.get(1).event == SimulationEvent.EventType.CustomerEnteredRatsies, 
								cust + " did not enter Ratsie! before leaving");
						check(e.get(2).event == SimulationEvent.EventType.CustomerPlacedOrder,
								cust + " did not place an order before leaving");
						check(e.get(3).event == SimulationEvent.EventType.CustomerReceivedOrder,
								cust + " did not receive an order before leaving");
						
					}
				}
				
				//Check to make sure the tables are never more full than they should be!
				int maxCustomersSeen = 0, customerSeen = 0; 
				for(int i = 0; i < events.size(); i++){
					if(events.get(i).event == SimulationEvent.EventType.CustomerEnteredRatsies){
						customerSeen++;
						if(customerSeen > maxCustomersSeen){
							maxCustomersSeen = customerSeen; 
						}
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerLeavingRatsies){
						customerSeen--;
						check(customerSeen >= 0, "Houston we have unaccounted for leaving "
								+ "statements!"); 
					}
				}
				
				check(maxCustomersSeen <= numTables, "You allowed more people than there are tables!" );
				check(customerSeen == 0, "Not everyone who entered has left!");
				//TODO: More validation steps
				//Look at the cook side of things. Start combining between cook and customer
				//Then get back to the machine...
				//Then Look at machine and cook. 
				//Also look at cook and food and order...
				
				HashMap<String, ArrayList<SimulationEvent>> cookEvents = new 
						HashMap<String, ArrayList<SimulationEvent>>();
				
				//NOW REPEAT THE PROCESS FOR THE COOK. 
				
				
				HashMap<String, ArrayList<Food>> orderMap = 
						new HashMap<String, ArrayList<Food>>();
				HashMap<String, ArrayList<Food>> prepareOrderMap = 
						new HashMap<String, ArrayList<Food>>();
				HashMap<String, Integer> cookOrderNum = 
						new HashMap<String, Integer>();
				HashMap<String, Integer> cookOrderSize = 
						new HashMap<String, Integer>();
				
				for(int i = 0; i < events.size(); i++){
					//For the cooks!!
					ArrayList<SimulationEvent> e; 
					ArrayList<Food> f; 
					ArrayList<Food> p; 
					
					if(events.get(i).event == SimulationEvent.EventType.CookStarting){
						String cook = events.get(i).cook.toString();
						check(!eventsMap.containsKey(cook),
								cook + " has already started!"); 
						e = new ArrayList<SimulationEvent>(); 
						e.add(events.get(i));
						eventsMap.put(cook,e);
						
					//If they enter, the next step is to make sure they first started!
					}else if(events.get(i).event == SimulationEvent.EventType.CookReceivedOrder){
						String cook = events.get(i).cook.toString();
						e = eventsMap.get(cook);
						
						check(e != null, cook + " has no record!");
						check(e.size() == 1, cook + " event array has weird size for RO");
						check(e.get(0).event == SimulationEvent.EventType.CookStarting, 
								cook + " did not start first before getting first order!");
						
						
						f = new ArrayList<Food>(); 		
						for(int j = 0; j < events.get(i).orderFood.size(); j++){
							f.add(events.get(i).orderFood.get(j));
						}
											
						orderMap.put(cook, f);
						prepareOrderMap.put(cook, new ArrayList<Food>());
						
						e.add(events.get(i));
						
						cookOrderNum.put(cook, events.get(i).orderNumber);
						cookOrderSize.put(cook, f.size());
					}else if(events.get(i).event == SimulationEvent.EventType.CookStartedFood){
						String cook = events.get(i).cook.toString();
						e = eventsMap.get(cook);
						f = orderMap.get(cook);
						p = prepareOrderMap.get(cook);
						
						check(e != null, cook + " has no record!");
						check(f != null, cook + " has no food!");
						check(p != null, cook + " has no set in preparedfood");
						check(events.get(i).orderNumber == cookOrderNum.get(cook), 
								cook +  " the order number is wrong for starting food!"); 
						check(f.contains(events.get(i).food), cook + " is cooking food not in order!");
						
						f.remove(events.get(i).food);
						p.add(events.get(i).food);
						
						e.add(events.get(i));
					}else if(events.get(i).event == SimulationEvent.EventType.CookFinishedFood){
						String cook = events.get(i).cook.toString();
						e = eventsMap.get(cook);
						p = prepareOrderMap.get(cook);
						
						check(e != null, cook + " has no record!");
						check(p != null, cook + " has no set in preparedfood");
						check(p.contains(events.get(i).food), cook + " finished food not in order!");
						check(events.get(i).orderNumber == cookOrderNum.get(cook), 
								cook +  " the order number is wrong for receiving food!"); 
						
						p.remove(events.get(i).food);
						
						e.add(events.get(i));
					}else if(events.get(i).event == SimulationEvent.EventType.CookCompletedOrder){
						String cook = events.get(i).cook.toString();
						e = eventsMap.get(cook);
						f = orderMap.get(cook);
						p = prepareOrderMap.get(cook);
						
						check(f.size() == 0, cook + " didn't prepare all food in order!");
						check(p.size() == 0, cook +  " didn't complete all food in the order!");
						check(events.get(i).orderNumber == cookOrderNum.get(cook), 
								cook +  " the order number is wrong for the completed order!");
						check(e.size() == 2 + 2 * cookOrderSize.get(cook), cook +  
								" is missing some events in its system!");
						
						//Clear the order!
						ArrayList<SimulationEvent> e2 = new ArrayList<SimulationEvent>();
						e2.add(e.get(0));
						
						eventsMap.put(cook, e2);
						cookOrderNum.remove(cook);
						cookOrderSize.remove(cook);
						orderMap.remove(cook);
						prepareOrderMap.remove(cook);

					}
				}
				
				double maxFryer = 0, currentFryer = 0; 
				double maxGriller = 0, currentGriller = 0; 
				double maxFountain = 0, currentFountain= 0; 
				double maxOven = 0, currentOven = 0; 
				
				for(int i = 0; i < events.size(); i++){
					if(events.get(i).event == SimulationEvent.EventType.MachineStartingFood){
						if(events.get(i).food == FoodType.pizza){
							
							currentOven++; 
							if(currentOven > maxOven) maxOven = currentOven;
						
						}else if(events.get(i).food == FoodType.soda){
							
							currentFountain++;
							if(currentFountain > maxFountain) maxFountain = currentFountain;
						
						}else if(events.get(i).food == FoodType.sub){
							
							currentGriller++; 
							if(currentGriller > maxGriller) maxGriller = currentGriller; 
						
						}else if(events.get(i).food == FoodType.wings){
							
							currentFryer++;
							if(currentFryer > maxFryer) maxFryer = currentFryer; 
							
						}
					}else if(events.get(i).event == SimulationEvent.EventType.MachineDoneFood){
						if(events.get(i).food == FoodType.pizza){
							
							currentOven = currentOven - 1; 
							check(currentOven >= 0, "Houston pizza is making food that doesn't exist");
						
						}else if(events.get(i).food == FoodType.soda){
							
							currentFountain = currentFountain - 1;
							check(currentFountain >= 0, "Houston soda "
									+ "is making food that doesn't exist");
						
						}else if(events.get(i).food == FoodType.sub){
							
							currentGriller = currentGriller - 1;
							check(currentGriller >= 0, "Houston sub "
									+ "is making food that doesn't exist");
						
						}else if(events.get(i).food == FoodType.wings){
							
							currentFryer = currentFryer - 1;
							check(currentGriller >= 0, "Houston wings "
									+ "is making food that doesn't exist");
							
						}
					}/*else if(events.get(i).event == SimulationEvent.EventType.CookFinishedFood){
						if(events.get(i).food == FoodType.pizza){
							
							currentOven = currentOven - 0.5; 
							check(currentOven >= 0, events.get(i).cook + ""
									+ " is making pizza that doesn't exist");
						
						}else if(events.get(i).food == FoodType.soda){
							
							currentFountain = currentFountain - 0.50;
							check(currentFountain >= 0, events.get(i).cook  
									+ " is making soda that doesn't exist");
						
						}else if(events.get(i).food == FoodType.sub){
							
							currentGriller = currentGriller - 0.50;
							check(currentGriller >= 0, events.get(i).cook
									+ "is making sub that doesn't exist");
						
						}else if(events.get(i).food == FoodType.wings){
							
							currentFryer = currentFryer - 0.50;
							check(currentGriller >= 0, events.get(i) 
									+ " is making wings that doesn't exist");
							
						}
					}*/
				}
				
				check(currentFryer == 0, "Fyer has mistaken braces");
				check(currentGriller == 0, "Griller has mistaken braces");
				check(currentFountain == 0, "Fountain has mistaken braces");
				check(currentOven == 0, "Oven has mistaken braces");
				
				/*
				System.out.println("---------");
				System.out.println(maxOven);	
				System.out.println(maxFryer);
				System.out.println(maxGriller);
				System.out.println(maxFountain);
				
				System.out.println("---------");*/
				
				check(maxOven <= machineCapacity, "Oven cooked more than max"); 
				check(maxFryer <= machineCapacity, "Fryer cooked more than max");
				check(maxGriller <= machineCapacity, "Griller cooked more than max");
				check(maxFountain <= machineCapacity, "Fountain cooked more than max");
				
				
				
				
				/******************************
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 * 
				 */
				
				//The final validation step. This is for all the marbles!
				HashMap<Integer, List<Food>> custOrderMap = new HashMap<Integer, List<Food>>();
				HashMap<String, Integer> custOrderNum = new HashMap<String, Integer>();
				ArrayList<String> cust = new ArrayList<String>();
				ArrayList<String> custHist = new ArrayList<String>();
				ArrayList<String> completeCustomers = new ArrayList<String>();
				
				
				//This is for the cooks!
				HashMap<String, Integer> cookOrderNums = new HashMap<String, Integer>(); 
				HashMap<String, List<Food>> cookOrderIn = new HashMap<String, List<Food>>();
				HashMap<String, List<Food>> cookOrderEnd = new HashMap<String, List<Food>>(); 
				ArrayList<Integer> completeOrderNum = new ArrayList<Integer>(); 
				
				//Machine stuff
				ArrayList<Food> machineIn = new ArrayList<Food>(); 
				ArrayList<Food> machineCooking = new ArrayList<Food>(); 
				ArrayList<Food> machineEnd = new ArrayList<Food>(); 
				
				for(int i = 0; i < events.size(); i++){
					
					if(events.get(i).event == SimulationEvent.EventType.CustomerPlacedOrder){
						String customer = events.get(i).customer.toString();
						check(!cust.contains(customer), "This customer is placing multiple orders!");
						check(!custHist.contains(customer), "This customer is placing multiple orders!");
						check(!custOrderMap.containsKey(events.get(i).orderNumber),
								"This order number already exists!");
						check(!custOrderNum.containsKey(events.get(i).customer.toString()),
								"Customer order number already exists");
						
						
						cust.add(events.get(i).customer.toString());
						custHist.add(events.get(i).customer.toString());
						custOrderMap.put(events.get(i).orderNumber, events.get(i).orderFood);
						custOrderNum.put(events.get(i).customer.toString(), events.get(i).orderNumber);
						
					}else if(events.get(i).event == SimulationEvent.EventType.CookReceivedOrder){
						
						String cook = events.get(i).cook.toString();
						int orderNum = events.get(i).orderNumber; 
						ArrayList<Food> fCopy = new ArrayList<Food>(); 
						
						//Now we check to make sure the order was placed by a customer
						check(cookOrderNum.get(cook) == null, "Why does " + cook + " number already exist?");
						check(cookOrderIn.get(cook) == null, "Why does " + cook + " order "  + 
						orderNum + " already exist?");
						
						check(custOrderMap.containsKey(events.get(i).orderNumber),
								"The specific order number doesn't exist!");
						//We also make sure the orders are consistent between customer and 
						//what the cook got
						for(int j = 0; j < events.get(i).orderFood.size(); j++){
							check(custOrderMap.get(orderNum).get(j) == 
									events.get(i).orderFood.get(j), "The order does not match! "+ cook);
							fCopy.add(events.get(i).orderFood.get(j));
						}
						
						//The cook claims the order and he has a copy of the food!
						cookOrderNums.put(cook, events.get(i).orderNumber);
						cookOrderIn.put(cook,fCopy); 
						
					}else if(events.get(i).event == SimulationEvent.EventType.CookStartedFood){
						String cook = events.get(i).cook.toString(); 
						int orderNum = events.get(i).orderNumber; 
						
						check(cookOrderNums.get(cook) == orderNum, cook + " hasn't started"
								+ "the damn order yet!"); 
						check(cookOrderIn.containsKey(cook), cook + " doesn't have a freaking order!");
						
						List<Food> f = cookOrderIn.get(cook);
						check(f.contains(events.get(i).food), cook + " doesn't have the food in "
								+ "this order!"); 
						
						//Now we take it out of the order b/c we are preparing it!
						f.remove(events.get(i).food);
						machineIn.add(events.get(i).food);
					}else if(events.get(i).event == SimulationEvent.EventType.MachineStartingFood){
						check(machineIn.contains(events.get(i).food), "Food has not been prepared!");
						
						machineIn.remove(events.get(i).food);
						machineCooking.add(events.get(i).food);
					}else if(events.get(i).event == SimulationEvent.EventType.MachineDoneFood){
						check(machineCooking.contains(events.get(i).food), "Food has not been cooked!");
						
						machineCooking.remove(events.get(i).food);
						machineEnd.add(events.get(i).food);
					}else if(events.get(i).event == SimulationEvent.EventType.CookFinishedFood){
						
						
						//Check to make sure orderNumber is correct!
						//Check to make sure the food has actually been cooked!
						//Add it to the final cooked list!
						String cook = events.get(i).cook.toString(); 
						int orderNum = events.get(i).orderNumber; 
						
						check(cookOrderNums.get(cook) == orderNum, cook + " has the wrong freaking"
								+ " order number!");
						check(machineEnd.contains(events.get(i).food), cook + " " + events.get(i).food + 
								" has not been cooked!");
						machineEnd.remove(events.get(i).food);
						
						List<Food> f; 
						if(!cookOrderEnd.containsKey(cook)){
							f = new ArrayList<Food>(); 
						}else{
							f =cookOrderEnd.get(cook);
						}
						
						f.add(events.get(i).food);
						
						cookOrderEnd.put(cook, f);
					}else if(events.get(i).event == SimulationEvent.EventType.CookCompletedOrder){
						String cook = events.get(i).cook.toString(); 
						int orderNum = events.get(i).orderNumber; 
						
						check(cookOrderNums.get(cook) == orderNum, cook + " has the wrong freaking"
								+ " order number!");
						//System.out.println(events.get(i));
						check(cookOrderEnd.containsKey(cook) || custOrderMap.get(orderNum).size() == 0, cook + " doesn't freaking exist in this"
								+ "map! Something went terribly wrong!");
						
						check(cookOrderIn.get(cook).size() == 0, cook + " not all foods were cooked for"
								+ " " + orderNum);
						
						
						//We want to make sure that the number of items this cook cooked
						//actually matches the order!
						
						
						int soda = 0, pizza = 0, wings = 0, subs = 0; 
						int custSoda = 0, custPizza = 0, custWings = 0, custSubs = 0;
						if(cookOrderEnd.containsKey(cook)){
							for(int j = 0; j < cookOrderEnd.get(cook).size(); j++){
								Food f = cookOrderEnd.get(cook).get(j);
								
								if(f == FoodType.pizza){
									pizza++;
								}else if(f == FoodType.soda){
									soda++;
								}else if(f == FoodType.sub){
									wings++;
								}else if(f == FoodType.wings){
									subs++;
								}
							}
						}
						
						for(int j = 0; j < custOrderMap.get(orderNum).size(); j++){
							Food f = custOrderMap.get(orderNum).get(j);
							
							if(f == FoodType.pizza){
								custPizza++;
							}else if(f == FoodType.soda){
								custSoda++;
							}else if(f == FoodType.sub){
								custWings++;
							}else if(f == FoodType.wings){
								custSubs++;
							}
						}
						
						
						check(pizza == custPizza, "The num pizzas arent the same!");
						check(soda == custSoda, "The num sodas aren't the same!");
						check(wings == custWings, "The number wings aren't the same!");
						check(subs == custSubs, "The number subs aren't the same!");
						
						cookOrderNum.remove(cook);
						cookOrderIn.remove(cook);
						cookOrderEnd.remove(cook);
						
						completeOrderNum.add(orderNum);
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerReceivedOrder){
						int orderNum = events.get(i).orderNumber;
						String customer = events.get(i).customer.toString();


						//We gotta make sure that  the orderNumber matches between this one
						//and the original number and that the order was actually completed!
						check(orderNum == custOrderNum.get(customer), customer + "with " +
						orderNum + ": The order number does not match!");
						check(completeOrderNum.contains(orderNum), customer + "with "+
						orderNum + ": The order number is not complete");
						
						//Gotta make sure that the order received matches the original order!
						for(int j = 0; j < events.get(i).orderFood.size(); j++){
							check(events.get(i).orderFood.get(j) == 
									custOrderMap.get(orderNum).get(j), customer + " the final "
											+ "orders do not match!! ACK!!!!");
						}
						
						completeOrderNum.remove(Integer.valueOf(orderNum));
						cust.remove(customer);
						completeCustomers.add(customer);
						custOrderMap.remove(orderNum);
						custOrderNum.remove(customer);
						
					}else if(events.get(i).event == SimulationEvent.EventType.CustomerLeavingRatsies){
						String customer = events.get(i).customer.toString(); 
						
						check(completeCustomers.contains(customer), "Customer did not finish order!");
						completeCustomers.remove(customer);
					}
				}
				
				check(machineIn.size() == 0, "MachineIn not completely cleared");
				check(machineCooking.size() == 0, "MachineCooking not completely cleared");
				check(machineEnd.size() == 0, "MachineEnd not completely cleared");
				check(cust.size() == 0, "cust not completely cleared");
				check(completeOrderNum.size() == 0, "completeOrderNum not completely cleared");
				check(completeCustomers.size() == 0, "completeCustomers not completely cleared");
				check(custOrderMap.keySet().size() == 0, "custOrderMap not completely cleared");
				check(custOrderNum.keySet().size() == 0, "custOrderNum not completely cleared");
				check(cookOrderNum.keySet().size() == 0, "cookORderNum not completely cleared");
				check(cookOrderIn.keySet().size() == 0, "cookORderIn not completely cleared");
				check(cookOrderEnd.keySet().size() == 0, "cookORderend not completely cleared");
				
			
			
			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
